<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Movie Edge</title>
    {% load static %}
    <script type="text/javascript" src="{% static 'movie_edge/d3.min.js' %}"></script>

    <style>
        .wrapper {
            width: 1000px;
            display: grid;
            grid-gap: 10px;
            grid-template-columns: repeat(3, 200px);
            grid-template-rows: repeat(3, 350px);
            grid-auto-flow: column;
        }

        .buttonSubmit {
            height: 64px;
            width: 128px;
        }

        .buttonGetRandom {
            height: 64px;
            width: 128px;
        }

        .scatter {
            fill: steelblue;
            stroke: #000;
        }

        body {
            overflow-x: hidden;
            overflow-y: hidden
        }

    </style>
</head>
<body>
<button class="buttonSubmit" type="button" onclick="buttonClickSubmit()">
    Click me for movie recommendations!
</button>
<button class="buttonGetRandom" type="button" onclick="buttonClickGetRandom()">
    Click on me for some more randomness!
</button>
<br>
<br>
<!--https://gridbyexample.com/examples/code/example18.html-->
<div class="wrapper" id="grid">
</div>
<div id="graph"></div>
</body>
<script>
    // https://stackoverflow.com/questions/38654599/django-best-way-to-pass-data-to-javascript
    const tableData = JSON.parse('{{ table_data|safe }}');
    console.log(tableData);
    const x_min = parseFloat(tableData['L5x__min']);
    const x_max = parseFloat(tableData['L5x__max']);
    const y_min = parseFloat(tableData['L5y__min']);
    const y_max = parseFloat(tableData['L5y__max']);
    const decoder = tableData['decoder'];
    let nineChoices = tableData['random_nine'];
    const width = window.innerWidth;
    const height = window.innerHeight;
    const padding = 25;
    const MOVIE_ID = 'movie_id';
    const MOVIE_TITLE = 'movie_title';
    const DIRECTOR = 'director';
    const ACTORS = 'actors';
    const TITLE = 'title';
    const GENRES = 'genres';
    const CLUSTER = 'cluster';
    const COLOR = 'color';
    const POSTER_URL = 'poster_url';
    const MOVIE_CHOICES = 'movie_choices';
    const LIKE = 'movies_liked';
    const DISLIKE = 'movies_disliked';
    const X = 'x';
    const Y = 'y';
    const moviesLiked = new Set(); // using set since it will do deduplication
    const moviesDisliked = new Set(); // using set since it will do deduplication
    const POSTER_HEIGHT = 300;
    const POSTER_WIDTH = 200;
    const zoomParams = {
        0: {r: 20, w: 2},
        1: {r: 10, w: 1},
        2: {r: 5, w: 0.5},
        3: {r: 2.5, w: 0.25},
        4: {r: 1.25, w: 0.125},
        5: {r: 0.5, w: 0.05},
        minZoom: 1,
        maxZoom: 50,
    };
    const bbox_pad = 0.25;
    const gridID = 'grid';
    const data = tableData['data'].map(function (r) {
            r[MOVIE_TITLE] = decodeURIComponent(r[MOVIE_TITLE]);
            r[DIRECTOR] = decodeURIComponent(r[DIRECTOR]);
            r[ACTORS] = decodeURIComponent(r[ACTORS]);
            return r
        }
    );

    function getCookie(name) {
        // https://docs.djangoproject.com/en/2.2/ref/csrf/
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function abstractFetch(fetchPayload, fetchURL) {
        console.log('Button Clicked');
        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
        const fetchParams = {
            method: 'POST',
            headers: {
                "X-CSRFToken": getCookie("csrftoken"),
                'Content-Type': 'application/json'
                {#'Content-Type': 'application/x-www-form-urlencoded'#}
            },
            body: JSON.stringify(fetchPayload),
            credentials: 'same-origin'
        };
        console.log(fetchParams);
        // https://scotch.io/tutorials/how-to-use-the-javascript-fetch-api-to-get-data
        // https://developers.google.com/web/fundamentals/primers/promises
        fetch(fetchURL, fetchParams)
            .then((response) => response.json())
            .then(function (data) {
                console.log(data);
                const movieChoices = data[MOVIE_CHOICES];
                console.log(movieChoices);
                gridNine(movieChoices);
            })
    }

    function buttonClickGetRandom() {
        const fetchURL = "{% url 'movie_edge:query_recommendations' %}";
        const fetchPayload = Object();
        fetchPayload[LIKE] = Array();
        fetchPayload[DISLIKE] = Array();
        abstractFetch(fetchPayload, fetchURL);
    }

    function buttonClickSubmit() {
        const fetchURL = "{% url 'movie_edge:query_recommendations' %}";
        const fetchPayload = Object();
        fetchPayload[LIKE] = Array.from(moviesLiked);
        fetchPayload[DISLIKE] = Array.from(moviesDisliked);
        abstractFetch(fetchPayload, fetchURL);
    }

    function buttonClickLike(data) {
        const movieId = data.target.value;
        if (moviesDisliked.has(movieId)) {
            moviesDisliked.delete(movieId);
        }
        moviesLiked.add(movieId);
        console.log(moviesLiked);
    }

    function buttonClickDislike(data) {
        const movieId = data.target.value;
        if (moviesLiked.has(movieId)) {
            moviesLiked.delete(movieId);
        }
        moviesDisliked.add(movieId);
        console.log(moviesDisliked);
    }

    function gridNine(movieidList) {
        // Delete current grid and redraw with new *choices*
        // https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript
        const grid = document.getElementById(gridID);
        while (grid.firstChild) {
            grid.removeChild(grid.firstChild);
        }
        // https://stackoverflow.com/questions/2735881/adding-images-to-an-html-document-with-javascript
        movieidList.forEach(function (movieId) {
                const dataIndex = decoder[movieId];
                console.log(dataIndex);
                const divNode = document.createElement('div');
                const imgNode = document.createElement('img');
                const buttonLike = document.createElement('BUTTON');
                buttonLike.innerText = 'Like';
                buttonLike.onclick = buttonClickLike;
                buttonLike.value = movieId;
                const buttonDislike = document.createElement('BUTTON');
                buttonDislike.innerText = 'Dislike';
                buttonDislike.onclick = buttonClickDislike;
                buttonDislike.value = movieId;
                imgNode.src = data[dataIndex][POSTER_URL];
                imgNode.height = POSTER_HEIGHT;
                imgNode.width = POSTER_WIDTH;
                grid.appendChild(divNode);
                divNode.appendChild(imgNode);
                divNode.appendChild(buttonLike);
                divNode.appendChild(buttonDislike);
                console.log(movieId);
            }
        )
    }

    gridNine(nineChoices);
    let visAnchor = {x: 0, y: 0};
    const currentZoom = 0;
    let lastScale = 1;
    const tmp = 0;
    let mybbox = {};
    let lastRedrawBbox = {};
    const xScale = d3.scaleLinear().domain([x_min, x_max]).range([0, width]);
    const yScale = d3.scaleLinear().domain([y_min, y_max]).range([height, 0]);
    const zScale = d3.scaleQuantize().domain([zoomParams.minZoom, zoomParams.maxZoom]).range([0, 1, 2, 3, 4, 5]);
    const svg = d3.select('#graph').append('svg').attr("width", width - 2 * padding).attr("height", height - 2 * padding);

    const g = svg.append("g")
        .attr("class", "holder");

    const resizeBbox = function (bbox, bigger) {
        const height = bbox.top - bbox.bot;
        const width = bbox.right - bbox.left;
        if (bigger) {
            return {
                top: bbox.top + height * bbox_pad,
                bot: bbox.bot - height * bbox_pad,
                left: bbox.left - width * bbox_pad,
                right: bbox.right + width * bbox_pad
            }
        } else {
            return {
                top: bbox.top - height * bbox_pad,
                bot: bbox.bot + height * bbox_pad,
                left: bbox.left + width * bbox_pad,
                right: bbox.right - width * bbox_pad
            }
        }


    };


    const bboxFilter = function (d, bbox, zoomLevel) {
        const x = d['L' + zoomLevel + 'x'];
        const y = d['L' + zoomLevel + 'y'];
        const biggerBbox = resizeBbox(bbox, true);
        const x_ok = x >= biggerBbox.left && x <= biggerBbox.right;
        const y_ok = y >= biggerBbox.bot && y <= biggerBbox.top;

        return x_ok && y_ok;


    };

    //https://stackoverflow.com/questions/42695480/d3v4-zoom-coordinates-of-visible-area
    function getVisibleArea(t) {
        const ul = t.invert([0, 0]),
            lr = t.invert([width, height]);
        return {
            left: Math.trunc(ul[0]),
            bot: Math.trunc(ul[1]),
            right: Math.trunc(lr[0]),
            top: Math.trunc(lr[1])
        }
    }


    const redraw = function (bbox, pad_bigger) {
        //clear old
        g.selectAll('.scatter').remove();
        g.selectAll('.logpoint').remove();
        //insert subset of points
        if (pad_bigger) {
            bbox = resizeBbox(bbox, true)
        }
        const fil = function (d) {
            return bboxFilter(d, bbox, currentZoom)
        };
        const subdata = data.filter(fil);
        g.selectAll('.scatter')
            .data(subdata)
            .enter()
            .append("circle")
            .attr("r", zoomParams[currentZoom]['r'])
            .attr("cx", function (d) {
                return xScale(d['L' + currentZoom + 'x'])
            })
            .attr("cy", function (d) {
                return yScale(d['L' + currentZoom + 'y'])
            })
            .attr("class", "scatter");
        //update visibility anchor
        console.log('Redraw');
        console.log(subdata.length);
        visAnchor = {
            x: (mybbox.left + mybbox.right) / 2,
            y: (mybbox.top + mybbox.bot) / 2
        };


        console.log(visAnchor);
        // drop a point at visAnchor just to check
        g.append('circle')
            .attr('cx', xScale(visAnchor.x))
            .attr('cy', yScale(visAnchor.y))
            .attr("class", "logpoint")
            .attr("r", 2)
            .style('fill', 'red');
        lastRedrawBbox = bbox;
    };


    g.selectAll('circle')
        .data(data)
        .enter()
        .append("circle")
        .attr("r", zoomParams[currentZoom]['r'])
        .attr("cx", function (d) {
            return xScale(d['L' + currentZoom + 'x'])
        })
        .attr("cy", function (d) {
            return yScale(d['L' + currentZoom + 'y'])
        })
        .attr("class", "scatter");

    const myzoom = d3.zoom()
        .extent([[0, 0], [width, height]])
        .scaleExtent([zoomParams.minZoom, zoomParams.maxZoom])
        .on("zoom", zoomed);

    svg.call(myzoom);


    function zoomed() {
        const tx = d3.event.transform;
        g.attr("transform", tx);
        k = d3.event.transform.k;
        const newZoom = zScale(k);
        const bbox_pixels = getVisibleArea(tx);

        const bbox = {
            top: yScale.invert(bbox_pixels.bot),
            bot: yScale.invert(bbox_pixels.top),
            left: xScale.invert(bbox_pixels.left),
            right: xScale.invert(bbox_pixels.right)
        };

        mybbox = bbox;

        // check if our anchor is in the bbox, if not we need to redraw
        const smallerBbox = resizeBbox(bbox, false);
        mybbox = smallerBbox;
        const x_ok = visAnchor.x >= smallerBbox.left && visAnchor.x <= smallerBbox.right;
        const y_ok = visAnchor.y >= smallerBbox.bot && visAnchor.y <= smallerBbox.top;
        if (!(x_ok && y_ok)) {

            redraw(bbox, false);
        }

        // if the entire  bbox from full redraw is in the frame, then we should redraw too. (just test the corners)
        if (k != lastScale) {
            if (lastRedrawBbox.top <= bbox.top || lastRedrawBbox.left >= bbox.left || lastRedrawBbox.right <= bbox.right || lastRedrawBbox.bot >= bbox.bot) {
                redraw(bbox, true);
            }
        }
        lastScale = k;


        // handle zoom changes
        if (newZoom != currentZoom) {
            console.log('Setting new zoom level ' + newZoom + ' ' + k);
            console.log(bbox);

            redraw(bbox, false);
            //transition
            const currentZoom = newZoom;
            g.selectAll('.scatter').transition().attr("duration", 3000)
                .attr("cx", function (d) {
                    return xScale(d['L' + currentZoom + 'x'])
                })
                .attr("cy", function (d) {
                    return yScale(d['L' + currentZoom + 'y'])
                })
                .attr("r", zoomParams[currentZoom]['r'])
                .attr("stroke-width", zoomParams[currentZoom]['w'])
            //.style("fill",Red_if_mybbox)

            /*
            g.append('rect')
                .attr('width',bbox.right-bbox.left)
                .attr('height',bbox.top-bbox.bot)
                .attr('x',bbox.left)
                .attr('y',bbox.bot)
                .attr('fill','red')*/
        }
    }
</script>
</html>