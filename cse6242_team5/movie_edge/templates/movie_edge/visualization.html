<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Movie Edge</title>
    {% load static %}
    <script type="text/javascript" src="{% static 'movie_edge/d3.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'movie_edge/grid_interactions.js' %}"></script>
    <script type="text/javascript" src="{% static 'movie_edge/constants.js' %}"></script>

    <style>
        .grid {
            width: 30%;
            display: grid;
            grid-gap: 10px;
            grid-template-columns: repeat(3, 200px);
            grid-template-rows: repeat(3, 350px);
            grid-auto-flow: column;
        }

        .buttonSubmit {
            height: 64px;
            width: 128px;
        }

        .buttonGetRandom {
            height: 64px;
            width: 128px;
        }

        .graph {
            width: 70%
        }

        .scatter {
            fill: steelblue;
            stroke: #000;
        }

        body {
            overflow-x: hidden;
            overflow-y: hidden
        }

    </style>
</head>
<body>
<button class="buttonSubmit" type="button" onclick="buttonClickSubmit()">
    Click me for movie recommendations!
</button>
<button class="buttonGetRandom" type="button" onclick="buttonClickGetRandom()">
    Click on me for some more randomness!
</button>
<br>
<br>
<!--https://gridbyexample.com/examples/code/example18.html-->
<div class="grid" id="grid">
</div>
<div class="graph" id="graph"></div>
</body>
{% csrf_token %}
<script>
    // https://stackoverflow.com/questions/38654599/django-best-way-to-pass-data-to-javascript
    const tableData = JSON.parse('{{ table_data|safe }}');
    console.log(tableData);
    const x_min = parseFloat(tableData['L5x__min']);
    const x_max = parseFloat(tableData['L5x__max']);
    const y_min = parseFloat(tableData['L5y__min']);
    const y_max = parseFloat(tableData['L5y__max']);
    const decoder = tableData['decoder'];
    let nineChoices = tableData['random_nine'];
    const width = window.innerWidth;
    const height = window.innerHeight;
    const data = tableData['data'].map(inputFormat);

    function buttonClickGetRandom() {
        const fetchURL = "{% url 'movie_edge:query_recommendations' %}";
        const fetchPayload = Object();
        fetchPayload[LIKE] = Array();
        fetchPayload[DISLIKE] = Array();
        abstractFetch(fetchPayload, fetchURL);
    }

    function buttonClickSubmit() {
        const fetchURL = "{% url 'movie_edge:query_recommendations' %}";
        const fetchPayload = Object();
        fetchPayload[LIKE] = Array.from(moviesLiked);
        fetchPayload[DISLIKE] = Array.from(moviesDisliked);
        abstractFetch(fetchPayload, fetchURL);
    }

    function getCookie(name) {
        // https://docs.djangoproject.com/en/2.2/ref/csrf/
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function abstractFetch(fetchPayload, fetchURL) {
        console.log('Button Clicked');
        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
        const fetchParams = {
            method: 'POST',
            headers: {
                "X-CSRFToken": getCookie('csrftoken'),
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(fetchPayload),
            credentials: 'same-origin'
        };
        console.log(fetchParams);
        // https://scotch.io/tutorials/how-to-use-the-javascript-fetch-api-to-get-data
        // https://developers.google.com/web/fundamentals/primers/promises
        fetch(fetchURL, fetchParams)
            .then((response) => response.json())
            .then(function (data) {
                console.log(data);
                const movieChoices = data[MOVIE_CHOICES];
                console.log(movieChoices);
                gridNine(movieChoices);
            })
    }


    gridNine(nineChoices);
    let visAnchor = {x: 0, y: 0};
    const currentZoom = 0;
    let lastScale = 1;
    const tmp = 0;
    let mybbox = {};
    let lastRedrawBbox = {};
    const xScale = d3.scaleLinear().domain([x_min, x_max]).range([0, width]);
    const yScale = d3.scaleLinear().domain([y_min, y_max]).range([height, 0]);
    const zScale = d3.scaleQuantize().domain([zoomParams.minZoom, zoomParams.maxZoom]).range([0, 1, 2, 3, 4, 5]);
    const svg = d3.select('#graph').append('svg').attr("width", width - 2 * padding).attr("height", height - 2 * padding);

    const g = svg.append("g")
        .attr("class", "holder");

    function redraw(bbox, pad_bigger) {
        //clear old
        g.selectAll('.scatter').remove();
        g.selectAll('.logpoint').remove();
        //insert subset of points
        if (pad_bigger) {
            bbox = resizeBbox(bbox, true)
        }
        const fil = function (d) {
            return bboxFilter(d, bbox, currentZoom)
        };
        const subdata = data.filter(fil);
        g.selectAll('.scatter')
            .data(subdata)
            .enter()
            .append("circle")
            .attr("r", zoomParams[currentZoom]['r'])
            .attr("cx", function (d) {
                return xScale(d['L' + currentZoom + 'x'])
            })
            .attr("cy", function (d) {
                return yScale(d['L' + currentZoom + 'y'])
            })
            .attr("class", "scatter");
        //update visibility anchor
        console.log('Redraw');
        console.log(subdata.length);
        visAnchor = {
            x: (mybbox.left + mybbox.right) / 2,
            y: (mybbox.top + mybbox.bot) / 2
        };

        console.log(visAnchor);
        // drop a point at visAnchor just to check
        g.append('circle')
            .attr('cx', xScale(visAnchor.x))
            .attr('cy', yScale(visAnchor.y))
            .attr("class", "logpoint")
            .attr("r", 2)
            .style('fill', 'red');
        lastRedrawBbox = bbox;
    }

    g.selectAll('circle')
        .data(data)
        .enter()
        .append("circle")
        .attr("r", zoomParams[currentZoom]['r'])
        .attr("cx", function (d) {
            return xScale(d['L' + currentZoom + 'x'])
        })
        .attr("cy", function (d) {
            return yScale(d['L' + currentZoom + 'y'])
        })
        .attr("class", "scatter");

    const myzoom = d3.zoom()
        .extent([[0, 0], [width, height]])
        .scaleExtent([zoomParams.minZoom, zoomParams.maxZoom])
        .on("zoom", zoomed);

    svg.call(myzoom);


    function zoomed() {
        const tx = d3.event.transform;
        g.attr("transform", tx);
        const k = d3.event.transform.k;
        const newZoom = zScale(k);
        const bbox_pixels = getVisibleArea(tx);

        const bbox = {
            top: yScale.invert(bbox_pixels.bot),
            bot: yScale.invert(bbox_pixels.top),
            left: xScale.invert(bbox_pixels.left),
            right: xScale.invert(bbox_pixels.right)
        };

        mybbox = bbox;

        // check if our anchor is in the bbox, if not we need to redraw
        const smallerBbox = resizeBbox(bbox, false);
        mybbox = smallerBbox;
        const x_ok = visAnchor.x >= smallerBbox.left && visAnchor.x <= smallerBbox.right;
        const y_ok = visAnchor.y >= smallerBbox.bot && visAnchor.y <= smallerBbox.top;
        if (!(x_ok && y_ok)) {

            redraw(bbox, false);
        }

        // if the entire  bbox from full redraw is in the frame, then we should redraw too. (just test the corners)
        if (k !== lastScale) {
            if (lastRedrawBbox.top <= bbox.top || lastRedrawBbox.left >= bbox.left || lastRedrawBbox.right <= bbox.right || lastRedrawBbox.bot >= bbox.bot) {
                redraw(bbox, true);
            }
        }
        lastScale = k;


        // handle zoom changes
        if (newZoom !== currentZoom) {
            console.log('Setting new zoom level ' + newZoom + ' ' + k);
            console.log(bbox);

            redraw(bbox, false);
            //transition
            const currentZoom = newZoom;
            g.selectAll('.scatter').transition().attr("duration", 3000)
                .attr("cx", function (d) {
                    return xScale(d['L' + currentZoom + 'x'])
                })
                .attr("cy", function (d) {
                    return yScale(d['L' + currentZoom + 'y'])
                })
                .attr("r", zoomParams[currentZoom]['r'])
                .attr("stroke-width", zoomParams[currentZoom]['w'])
            //.style("fill",Red_if_mybbox)

            /*
            g.append('rect')
                .attr('width',bbox.right-bbox.left)
                .attr('height',bbox.top-bbox.bot)
                .attr('x',bbox.left)
                .attr('y',bbox.bot)
                .attr('fill','red')*/
        }
    }
</script>
</html>